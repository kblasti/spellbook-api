// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: characters.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const addCharacterSpell = `-- name: AddCharacterSpell :one
INSERT INTO characters_spells (spell_id, char_id)
VALUES (
    $1,
    $2
)
RETURNING spell_id, char_id
`

type AddCharacterSpellParams struct {
	SpellID int32
	CharID  uuid.UUID
}

func (q *Queries) AddCharacterSpell(ctx context.Context, arg AddCharacterSpellParams) (CharactersSpell, error) {
	row := q.db.QueryRowContext(ctx, addCharacterSpell, arg.SpellID, arg.CharID)
	var i CharactersSpell
	err := row.Scan(&i.SpellID, &i.CharID)
	return i, err
}

const createCharacter = `-- name: CreateCharacter :one
INSERT INTO characters (id, name, class_levels, created_at, updated_at, user_id)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    NOW(),
    NOW(),
    $3
)
RETURNING id, name, class_levels
`

type CreateCharacterParams struct {
	Name        string
	ClassLevels json.RawMessage
	UserID      uuid.UUID
}

type CreateCharacterRow struct {
	ID          uuid.UUID
	Name        string
	ClassLevels json.RawMessage
}

func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (CreateCharacterRow, error) {
	row := q.db.QueryRowContext(ctx, createCharacter, arg.Name, arg.ClassLevels, arg.UserID)
	var i CreateCharacterRow
	err := row.Scan(&i.ID, &i.Name, &i.ClassLevels)
	return i, err
}

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters
WHERE id = $1 AND user_id = $2
`

type DeleteCharacterParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteCharacter(ctx context.Context, arg DeleteCharacterParams) error {
	_, err := q.db.ExecContext(ctx, deleteCharacter, arg.ID, arg.UserID)
	return err
}

const getCasterLevel = `-- name: GetCasterLevel :one
SELECT 
    FLOOR( 
        COALESCE((class_levels->>'wizard')::numeric, 0) * 1 + 
        COALESCE((class_levels->>'cleric')::numeric, 0) * 1 + 
        COALESCE((class_levels->>'druid')::numeric, 0) * 1 + 
        COALESCE((class_levels->>'bard')::numeric, 0) * 1 + 
        COALESCE((class_levels->>'sorcerer')::numeric, 0) * 1 + 
        COALESCE((class_levels->>'paladin')::numeric, 0) * 0.5 + 
        COALESCE((class_levels->>'ranger')::numeric, 0) * 0.5
    ) AS effective_caster_level 
FROM characters 
WHERE id = $1
`

func (q *Queries) GetCasterLevel(ctx context.Context, id uuid.UUID) (float64, error) {
	row := q.db.QueryRowContext(ctx, getCasterLevel, id)
	var effective_caster_level float64
	err := row.Scan(&effective_caster_level)
	return effective_caster_level, err
}

const getCharacterSpells = `-- name: GetCharacterSpells :many
SELECT s."index", s.name, s.level, s.url
FROM spells as s
JOIN characters_spells AS cs ON cs.spell_id = s.id
JOIN characters AS c ON c.id = cs.char_id
WHERE c.id = $1
ORDER BY s.level, s.name
`

type GetCharacterSpellsRow struct {
	Index string
	Name  string
	Level sql.NullInt32
	Url   string
}

func (q *Queries) GetCharacterSpells(ctx context.Context, id uuid.UUID) ([]GetCharacterSpellsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCharacterSpells, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCharacterSpellsRow
	for rows.Next() {
		var i GetCharacterSpellsRow
		if err := rows.Scan(
			&i.Index,
			&i.Name,
			&i.Level,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClassLevels = `-- name: GetClassLevels :one
SELECT class_levels
FROM characters
WHERE id = $1
`

func (q *Queries) GetClassLevels(ctx context.Context, id uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getClassLevels, id)
	var class_levels json.RawMessage
	err := row.Scan(&class_levels)
	return class_levels, err
}

const getSpellSlotsMax = `-- name: GetSpellSlotsMax :one
SELECT slots 
FROM spell_slots 
WHERE caster_type = $1 AND caster_level = $2
`

type GetSpellSlotsMaxParams struct {
	CasterType  string
	CasterLevel int32
}

func (q *Queries) GetSpellSlotsMax(ctx context.Context, arg GetSpellSlotsMaxParams) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getSpellSlotsMax, arg.CasterType, arg.CasterLevel)
	var slots json.RawMessage
	err := row.Scan(&slots)
	return slots, err
}

const getUserCharacters = `-- name: GetUserCharacters :many
SELECT id, name, class_levels
FROM characters
WHERE user_id = $1
`

type GetUserCharactersRow struct {
	ID          uuid.UUID
	Name        string
	ClassLevels json.RawMessage
}

func (q *Queries) GetUserCharacters(ctx context.Context, userID uuid.UUID) ([]GetUserCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCharacters, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserCharactersRow
	for rows.Next() {
		var i GetUserCharactersRow
		if err := rows.Scan(&i.ID, &i.Name, &i.ClassLevels); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCharacterSpell = `-- name: RemoveCharacterSpell :exec
DELETE FROM characters_spells
WHERE spell_id = $1 AND char_id = $2
`

type RemoveCharacterSpellParams struct {
	SpellID int32
	CharID  uuid.UUID
}

func (q *Queries) RemoveCharacterSpell(ctx context.Context, arg RemoveCharacterSpellParams) error {
	_, err := q.db.ExecContext(ctx, removeCharacterSpell, arg.SpellID, arg.CharID)
	return err
}

const updateCharacter = `-- name: UpdateCharacter :one
UPDATE characters
SET name = $1, class_levels = $2, updated_at = NOW()
WHERE id = $3
RETURNING id, name, class_levels
`

type UpdateCharacterParams struct {
	Name        string
	ClassLevels json.RawMessage
	ID          uuid.UUID
}

type UpdateCharacterRow struct {
	ID          uuid.UUID
	Name        string
	ClassLevels json.RawMessage
}

func (q *Queries) UpdateCharacter(ctx context.Context, arg UpdateCharacterParams) (UpdateCharacterRow, error) {
	row := q.db.QueryRowContext(ctx, updateCharacter, arg.Name, arg.ClassLevels, arg.ID)
	var i UpdateCharacterRow
	err := row.Scan(&i.ID, &i.Name, &i.ClassLevels)
	return i, err
}
